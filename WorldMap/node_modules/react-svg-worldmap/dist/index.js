"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.regions = exports.WorldMap = void 0;
const react_1 = require("react");
const d3_geo_1 = require("d3-geo");
const countries_geo_1 = require("./countries.geo");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const draw_1 = require("./draw");
const Frame_1 = require("./components/Frame");
const Region_1 = require("./components/Region");
const TextLabel_1 = require("./components/TextLabel");
function toValue({ value }) {
    return typeof value === "string" ? 0 : value;
}
function WorldMap(props) {
    const { data, title, valuePrefix = "", valueSuffix = "", color = constants_1.defaultColor, strokeOpacity = 0.2, backgroundColor = "white", tooltipBgColor = "black", tooltipTextColor = "white", size = constants_1.defaultSize, frame = false, frameColor = "black", borderColor = "black", richInteraction = false, styleFunction = (0, constants_1.defaultCountryStyle)(borderColor, strokeOpacity), tooltipTextFunction = constants_1.defaultTooltip, onClickFunction, hrefFunction, textLabelFunction = () => [], } = props;
    const windowWidth = (0, utils_1.useWindowWidth)();
    // Inits
    const width = typeof size === "number" ? size : (0, utils_1.responsify)(size, windowWidth);
    const height = width * constants_1.heightRatio;
    const [scale, setScale] = (0, react_1.useState)(1);
    const [translateX, setTranslateX] = (0, react_1.useState)(0);
    const [translateY, setTranslateY] = (0, react_1.useState)(0);
    const containerRef = (0, react_1.createRef)();
    // Calc min/max values and build country map for direct access
    const countryValueMap = Object.fromEntries(data.map(({ country, value }) => [country.toUpperCase(), value]));
    const minValue = Math.min(...data.map(toValue));
    const maxValue = Math.max(...data.map(toValue));
    // Build a path & a tooltip for each country
    const projection = (0, d3_geo_1.geoMercator)();
    const pathGenerator = (0, d3_geo_1.geoPath)().projection(projection);
    const onClick = react_1.default.useCallback((context) => (event) => onClickFunction?.({ ...context, event }), [onClickFunction]);
    const regions = countries_geo_1.default.features.map((feature) => {
        const triggerRef = (0, react_1.createRef)();
        const { I: isoCode, N: countryName, C: coordinates } = feature;
        const geoFeature = {
            type: "Feature",
            properties: { NAME: countryName, ISO_A2: isoCode },
            geometry: {
                type: "MultiPolygon",
                coordinates: coordinates,
            },
        };
        const context = {
            countryCode: isoCode,
            countryValue: countryValueMap[isoCode],
            countryName,
            color,
            minValue,
            maxValue,
            prefix: valuePrefix,
            suffix: valueSuffix,
        };
        const path = (react_1.default.createElement(Region_1.default, { ref: triggerRef, d: pathGenerator(geoFeature), style: styleFunction(context), onClick: onClick(context), strokeOpacity: strokeOpacity, href: hrefFunction?.(context), key: countryName }));
        const tooltip = (0, draw_1.drawTooltip)(typeof context.countryValue === "undefined"
            ? undefined
            : tooltipTextFunction(context), tooltipBgColor, tooltipTextColor, triggerRef, containerRef);
        return { path, highlightedTooltip: tooltip };
    });
    // Build paths
    const regionPaths = regions.map((entry) => entry.path);
    // Build tooltips
    const regionTooltips = regions.map((entry) => entry.highlightedTooltip);
    const eventHandlers = {
        onMouseDown(e) {
            e.preventDefault();
            e.stopPropagation();
        },
        onDoubleClick(e) {
            const rect = e.currentTarget.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (scale === 4) {
                setTranslateX(0);
                setTranslateY(0);
                setScale(1);
            }
            else {
                setTranslateX(2 * translateX - x);
                setTranslateY(2 * translateY - y);
                setScale(scale * 2);
            }
        },
    };
    // Render the SVG
    return (react_1.default.createElement("figure", { className: "worldmap__figure-container", style: { backgroundColor } },
        title && (react_1.default.createElement("figcaption", { className: "worldmap__figure-caption" }, title)),
        react_1.default.createElement("svg", { ref: containerRef, height: `${height}px`, width: `${width}px`, ...(richInteraction ? eventHandlers : undefined) },
            frame && react_1.default.createElement(Frame_1.default, { color: frameColor }),
            react_1.default.createElement("g", { transform: `translate(${translateX}, ${translateY}) scale(${(width / 960) * scale}) translate(0, 240)`, style: { transition: "all 0.2s" } }, regionPaths),
            react_1.default.createElement("g", null, textLabelFunction(width).map((labelProps) => (react_1.default.createElement(TextLabel_1.default, { ...labelProps, key: labelProps.label })))),
            regionTooltips)));
}
exports.default = WorldMap;
exports.WorldMap = WorldMap;
const regions = countries_geo_1.default.features.map((g) => ({ name: g.N, code: g.I }));
exports.regions = regions;
//# sourceMappingURL=index.js.map